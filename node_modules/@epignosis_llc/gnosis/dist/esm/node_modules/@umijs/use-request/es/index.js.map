{"version":3,"file":"index.js","sources":["../../../../../../node_modules/@umijs/use-request/es/index.js"],"sourcesContent":["function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useRef, useContext } from 'react';\nimport request from 'umi-request';\nimport useAsync from './useAsync';\nimport useLoadMore from './useLoadMore';\nimport usePaginated from './usePaginated';\nimport ConfigContext from './configContext';\n\nfunction useRequest(service) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var contextConfig = useContext(ConfigContext);\n\n  var finalOptions = _objectSpread({}, contextConfig, {}, options);\n\n  var paginated = finalOptions.paginated,\n      loadMore = finalOptions.loadMore,\n      requestMethod = finalOptions.requestMethod;\n  var paginatedRef = useRef(paginated);\n  var loadMoreRef = useRef(loadMore);\n\n  if (paginatedRef.current !== paginated) {\n    throw Error('You should not modify the paginated of options');\n  }\n\n  if (loadMoreRef.current !== loadMore) {\n    throw Error('You should not modify the loadMore of options');\n  }\n\n  paginatedRef.current = paginated;\n  loadMoreRef.current = loadMore;\n  var finalRequestMethod = requestMethod || request;\n  var promiseService;\n\n  if (typeof service === 'string') {\n    promiseService = function promiseService() {\n      return finalRequestMethod(service);\n    };\n  } else if (_typeof(service) === 'object') {\n    var url = service.url,\n        rest = _objectWithoutProperties(service, [\"url\"]);\n\n    promiseService = function promiseService() {\n      return requestMethod ? requestMethod(service) : request(url, rest);\n    };\n  } else {\n    promiseService = function promiseService() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return new Promise(function (resolve, reject) {\n        var result = service.apply(void 0, args);\n\n        if (result.then) {\n          result.then(function (data) {\n            return resolve(data);\n          }).catch(function (e) {\n            return reject(e);\n          });\n        } else if (typeof result === 'string') {\n          finalRequestMethod(result).then(function (data) {\n            resolve(data);\n          }).catch(function (e) {\n            return reject(e);\n          });\n        } else if (_typeof(result) === 'object') {\n          // umi-request 需要拆分下字段\n          if (requestMethod) {\n            finalRequestMethod(result).then(function (data) {\n              resolve(data);\n            }).catch(function (e) {\n              return reject(e);\n            });\n          } else {\n            var _url = result.url,\n                _rest = _objectWithoutProperties(result, [\"url\"]);\n\n            request(_url, _rest).then(function (data) {\n              resolve(data);\n            }).catch(function (e) {\n              return reject(e);\n            });\n          }\n        }\n      });\n    };\n  }\n\n  if (loadMore) {\n    return useLoadMore(promiseService, finalOptions);\n  }\n\n  if (paginated) {\n    return usePaginated(promiseService, finalOptions);\n  }\n\n  return useAsync(promiseService, finalOptions);\n}\n\nvar UseAPIProvider = ConfigContext.Provider;\nexport { useAsync, usePaginated, useLoadMore, UseAPIProvider };\nexport default useRequest;"],"names":[],"mappings":";;;;;;;;;;;;;;;;AA8GqB,aAAa,CAAC"}