{"version":3,"file":"animation-state.mjs.js","sources":["../../../../../../../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { __spreadArray, __read, __assign, __rest } from 'tslib';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { animateVisualElement } from './animation.mjs';\nimport { AnimationType } from './types.mjs';\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.mjs';\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.InView,\n    AnimationType.Focus,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = __assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            var shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev) || variantDidChange) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: __assign({ type: type }, options),\n                }); })), false));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = __assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        var animations = animateChanges(options, type);\n        for (var key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.InView] = createTypeState(),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nexport { checkVariantsDidChange, createAnimationState, variantPriorityOrder };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAQG,IAAC,oBAAoB,GAAG;AAC3B,IAAI,aAAa,CAAC,OAAO;AACzB,IAAI,aAAa,CAAC,MAAM;AACxB,IAAI,aAAa,CAAC,KAAK;AACvB,IAAI,aAAa,CAAC,KAAK;AACvB,IAAI,aAAa,CAAC,GAAG;AACrB,IAAI,aAAa,CAAC,IAAI;AACtB,IAAI,aAAa,CAAC,IAAI;AACtB,EAAE;AACF,IAAI,oBAAoB,GAAG,aAAa,CAAC,EAAE,EAAE,MAAM,CAAC,oBAAoB,CAAC,EAAE,KAAK,CAAC,CAAC,OAAO,EAAE,CAAC;AAC5F,IAAI,iBAAiB,GAAG,oBAAoB,CAAC,MAAM,CAAC;AACpD,SAAS,WAAW,CAAC,aAAa,EAAE;AACpC,IAAI,OAAO,UAAU,UAAU,EAAE;AACjC,QAAQ,OAAO,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE;AACxD,YAAY,IAAI,SAAS,GAAG,EAAE,CAAC,SAAS,EAAE,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;AAC/D,YAAY,OAAO,oBAAoB,CAAC,aAAa,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AAC3E,SAAS,CAAC,CAAC,CAAC;AACZ,KAAK,CAAC;AACN,CAAC;AACD,SAAS,oBAAoB,CAAC,aAAa,EAAE;AAC7C,IAAI,IAAI,OAAO,GAAG,WAAW,CAAC,aAAa,CAAC,CAAC;AAC7C,IAAI,IAAI,KAAK,GAAG,WAAW,EAAE,CAAC;AAC9B,IAAI,IAAI,eAAe,GAAG,EAAE,CAAC;AAC7B,IAAI,IAAI,eAAe,GAAG,IAAI,CAAC;AAC/B;AACA;AACA;AACA;AACA,IAAI,IAAI,uBAAuB,GAAG,UAAU,GAAG,EAAE,UAAU,EAAE;AAC7D,QAAQ,IAAI,QAAQ,GAAG,cAAc,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;AACjE,QAAQ,IAAI,QAAQ,EAAE;AACtB,YAAY,QAAQ,CAAC,UAAU,CAAC,CAAC,IAAI,aAAa,GAAG,QAAQ,CAAC,aAAa,EAAE,MAAM,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC,CAAC;AACxI,YAAY,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE,aAAa,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK,CAAC;AACN,IAAI,SAAS,UAAU,CAAC,GAAG,EAAE;AAC7B,QAAQ,OAAO,eAAe,CAAC,GAAG,CAAC,KAAK,SAAS,CAAC;AAClD,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,SAAS,kBAAkB,CAAC,YAAY,EAAE;AAC9C,QAAQ,OAAO,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC;AAC9C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,SAAS,cAAc,CAAC,OAAO,EAAE,iBAAiB,EAAE;AACxD,QAAQ,IAAI,EAAE,CAAC;AACf,QAAQ,IAAI,KAAK,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC;AAC7C,QAAQ,IAAI,OAAO,GAAG,aAAa,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;AAClE;AACA;AACA;AACA;AACA,QAAQ,IAAI,UAAU,GAAG,EAAE,CAAC;AAC5B;AACA;AACA;AACA;AACA,QAAQ,IAAI,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI,eAAe,GAAG,EAAE,CAAC;AACjC;AACA;AACA;AACA;AACA,QAAQ,IAAI,mBAAmB,GAAG,QAAQ,CAAC;AAC3C,QAAQ,IAAI,OAAO,GAAG,UAAU,CAAC,EAAE;AACnC,YAAY,IAAI,IAAI,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;AAC/C,YAAY,IAAI,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;AACxC,YAAY,IAAI,IAAI,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;AACzF,YAAY,IAAI,aAAa,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;AACrD;AACA;AACA;AACA;AACA,YAAY,IAAI,WAAW,GAAG,IAAI,KAAK,iBAAiB,GAAG,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;AACrF,YAAY,IAAI,WAAW,KAAK,KAAK;AACrC,gBAAgB,mBAAmB,GAAG,CAAC,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,WAAW,GAAG,IAAI,KAAK,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC;AAC9F;AACA;AACA;AACA,YAAY,IAAI,WAAW;AAC3B,gBAAgB,eAAe;AAC/B,gBAAgB,aAAa,CAAC,sBAAsB,EAAE;AACtD,gBAAgB,WAAW,GAAG,KAAK,CAAC;AACpC,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,SAAS,CAAC,aAAa,GAAG,QAAQ,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;AACpE;AACA,YAAY;AACZ;AACA,YAAY,CAAC,CAAC,SAAS,CAAC,QAAQ,IAAI,WAAW,KAAK,IAAI;AACxD;AACA,iBAAiB,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;AAC9C;AACA,gBAAgB,mBAAmB,CAAC,IAAI,CAAC;AACzC,gBAAgB,OAAO,IAAI,KAAK,SAAS,EAAE;AAC3C,gBAAgB,OAAO,UAAU,CAAC;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,gBAAgB,GAAG,sBAAsB,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AACpF,YAAY,IAAI,iBAAiB,GAAG,gBAAgB;AACpD;AACA,iBAAiB,IAAI,KAAK,iBAAiB;AAC3C,oBAAoB,SAAS,CAAC,QAAQ;AACtC,oBAAoB,CAAC,WAAW;AAChC,oBAAoB,aAAa,CAAC;AAClC;AACA,iBAAiB,CAAC,GAAG,mBAAmB,IAAI,aAAa,CAAC,CAAC;AAC3D;AACA;AACA;AACA;AACA,YAAY,IAAI,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;AACrE;AACA;AACA;AACA;AACA,YAAY,IAAI,cAAc,GAAG,cAAc,CAAC,MAAM,CAAC,uBAAuB,EAAE,EAAE,CAAC,CAAC;AACpF,YAAY,IAAI,WAAW,KAAK,KAAK;AACrC,gBAAgB,cAAc,GAAG,EAAE,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,EAAE,GAAG,SAAS,CAAC,kBAAkB,EAAE,kBAAkB,GAAG,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AAChG,YAAY,IAAI,OAAO,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,kBAAkB,CAAC,EAAE,cAAc,CAAC,CAAC;AACrF,YAAY,IAAI,aAAa,GAAG,UAAU,GAAG,EAAE;AAC/C,gBAAgB,iBAAiB,GAAG,IAAI,CAAC;AACzC,gBAAgB,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACxC,gBAAgB,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;AACrD,aAAa,CAAC;AACd,YAAY,KAAK,IAAI,GAAG,IAAI,OAAO,EAAE;AACrC,gBAAgB,IAAI,IAAI,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC;AAC/C,gBAAgB,IAAI,IAAI,GAAG,kBAAkB,CAAC,GAAG,CAAC,CAAC;AACnD;AACA,gBAAgB,IAAI,eAAe,CAAC,cAAc,CAAC,GAAG,CAAC;AACvD,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,gBAAgB,IAAI,IAAI,KAAK,IAAI,EAAE;AACnC;AACA;AACA;AACA;AACA,oBAAoB,IAAI,iBAAiB,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;AAC5E,wBAAwB,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,gBAAgB,EAAE;AAC7E,4BAA4B,aAAa,CAAC,GAAG,CAAC,CAAC;AAC/C,yBAAyB;AACzB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4BAA4B,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;AAChE,yBAAyB;AACzB,qBAAqB;AACrB,yBAAyB,IAAI,IAAI,KAAK,SAAS,EAAE;AACjD;AACA,wBAAwB,aAAa,CAAC,GAAG,CAAC,CAAC;AAC3C,qBAAqB;AACrB,yBAAyB;AACzB;AACA,wBAAwB,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7C,qBAAqB;AACrB,iBAAiB;AACjB,qBAAqB,IAAI,IAAI,KAAK,SAAS,IAAI,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AACrE;AACA;AACA;AACA;AACA,oBAAoB,aAAa,CAAC,GAAG,CAAC,CAAC;AACvC,iBAAiB;AACjB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;AACxD,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;AACtC,YAAY,SAAS,CAAC,kBAAkB,GAAG,cAAc,CAAC;AAC1D;AACA;AACA;AACA,YAAY,IAAI,SAAS,CAAC,QAAQ,EAAE;AACpC,gBAAgB,eAAe,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,eAAe,CAAC,EAAE,cAAc,CAAC,CAAC;AAC1F,aAAa;AACb,YAAY,IAAI,eAAe,IAAI,aAAa,CAAC,qBAAqB,EAAE;AACxE,gBAAgB,iBAAiB,GAAG,KAAK,CAAC;AAC1C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,iBAAiB,IAAI,CAAC,WAAW,EAAE;AACnD,gBAAgB,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,aAAa,CAAC,EAAE,EAAE,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,SAAS,EAAE,EAAE,QAAQ;AAC7H,oBAAoB,SAAS,EAAE,SAAS;AACxC,oBAAoB,OAAO,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,OAAO,CAAC;AAC9D,iBAAiB,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACjC,aAAa;AACb,SAAS,CAAC;AACV;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,EAAE,EAAE;AACpD,YAAY,OAAO,CAAC,CAAC,CAAC,CAAC;AACvB,SAAS;AACT,QAAQ,eAAe,GAAG,QAAQ,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;AACxD;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI,WAAW,CAAC,IAAI,EAAE;AAC9B,YAAY,IAAI,mBAAmB,GAAG,EAAE,CAAC;AACzC,YAAY,WAAW,CAAC,OAAO,CAAC,UAAU,GAAG,EAAE;AAC/C,gBAAgB,IAAI,cAAc,GAAG,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;AACtE,gBAAgB,IAAI,cAAc,KAAK,SAAS,EAAE;AAClD,oBAAoB,mBAAmB,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC;AAC9D,iBAAiB;AACjB,aAAa,CAAC,CAAC;AACf,YAAY,UAAU,CAAC,IAAI,CAAC,EAAE,SAAS,EAAE,mBAAmB,EAAE,CAAC,CAAC;AAChE,SAAS;AACT,QAAQ,IAAI,aAAa,GAAG,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AACvD,QAAQ,IAAI,eAAe;AAC3B,YAAY,KAAK,CAAC,OAAO,KAAK,KAAK;AACnC,YAAY,CAAC,aAAa,CAAC,sBAAsB,EAAE;AACnD,YAAY,aAAa,GAAG,KAAK,CAAC;AAClC,SAAS;AACT,QAAQ,eAAe,GAAG,KAAK,CAAC;AAChC,QAAQ,OAAO,aAAa,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;AACvE,KAAK;AACL;AACA;AACA;AACA,IAAI,SAAS,SAAS,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAChD,QAAQ,IAAI,EAAE,CAAC;AACf;AACA,QAAQ,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,QAAQ,KAAK,QAAQ;AAC7C,YAAY,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;AACrC;AACA,QAAQ,CAAC,EAAE,GAAG,aAAa,CAAC,eAAe,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,UAAU,KAAK,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,EAAE,GAAG,KAAK,CAAC,cAAc,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;AACjO,QAAQ,KAAK,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACxC,QAAQ,IAAI,UAAU,GAAG,cAAc,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACvD,QAAQ,KAAK,IAAI,GAAG,IAAI,KAAK,EAAE;AAC/B,YAAY,KAAK,CAAC,GAAG,CAAC,CAAC,aAAa,GAAG,EAAE,CAAC;AAC1C,SAAS;AACT,QAAQ,OAAO,UAAU,CAAC;AAC1B,KAAK;AACL,IAAI,OAAO;AACX,QAAQ,UAAU,EAAE,UAAU;AAC9B,QAAQ,cAAc,EAAE,cAAc;AACtC,QAAQ,SAAS,EAAE,SAAS;AAC5B,QAAQ,kBAAkB,EAAE,kBAAkB;AAC9C,QAAQ,QAAQ,EAAE,YAAY,EAAE,OAAO,KAAK,CAAC,EAAE;AAC/C,KAAK,CAAC;AACN,CAAC;AACD,SAAS,sBAAsB,CAAC,IAAI,EAAE,IAAI,EAAE;AAC5C,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AAClC,QAAQ,OAAO,IAAI,KAAK,IAAI,CAAC;AAC7B,KAAK;AACL,SAAS,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;AACpC,QAAQ,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,SAAS,eAAe,CAAC,QAAQ,EAAE;AACnC,IAAI,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE,EAAE,QAAQ,GAAG,KAAK,CAAC,EAAE;AAClD,IAAI,OAAO;AACX,QAAQ,QAAQ,EAAE,QAAQ;AAC1B,QAAQ,aAAa,EAAE,EAAE;AACzB,QAAQ,cAAc,EAAE,EAAE;AAC1B,QAAQ,kBAAkB,EAAE,EAAE;AAC9B,KAAK,CAAC;AACN,CAAC;AACD,SAAS,WAAW,GAAG;AACvB,IAAI,IAAI,EAAE,CAAC;AACX,IAAI,OAAO,EAAE,GAAG,EAAE;AAClB,QAAQ,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,GAAG,eAAe,CAAC,IAAI,CAAC;AACzD,QAAQ,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC,GAAG,eAAe,EAAE;AACpD,QAAQ,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,EAAE;AACnD,QAAQ,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,eAAe,EAAE;AACjD,QAAQ,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,eAAe,EAAE;AAClD,QAAQ,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,EAAE;AACnD,QAAQ,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,eAAe,EAAE;AAClD,QAAQ,EAAE,CAAC;AACX;;;;"}